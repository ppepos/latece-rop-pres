<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				
<section>
<section data-markdown>
<script type="text/template">
# Introduction aux techniques modernes d'exploitation binaire

</script>
</section>
<section data-markdown>
<script type="text/template">
## Sujets

 * Rétro-ingénierie
 * Exploitation
 * x86, x86_64
 * *Return-Oriented Programming*

</script>
</section>
<section data-markdown>
<script type="text/template">
## Plan

 * Présentation de l'application cible
 * Rétro-ingénierie
 * *Segmentation Fault* et retour sur la convention d'appel GNU/Linux x86
 * Exploitation simple
 * Protection de segments de mémoire
 * Réutilisation de code (*Ret2libc*)
 * Réutilisation de segments de code (*ROP*)


</script>
</section>
<section data-markdown>
<script type="text/template">
## Cheminement

 1. Application cible 32 bits
 1. Analyse d'un<!-- .element: class="fragment" data-fragment-index="1" --> *Segmentation fault* <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Developpement d'un exploit simple avec injection de code <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Recompilation avec le bit <!-- .element: class="fragment" data-fragment-index="1" --> `NX` activé <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Exploit sans injection de code <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Recompilation en 64 bits (Changement de la convention d'appel) <!-- .element: class="fragment" data-fragment-index="1" -->
 1. Exploitation en utilisant le *ROP*

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
## Cible

Version réécrite du défi TVStation du *Securityfest CTF*.

</script>
</section>
<section>
<script type="text/javascript" src="https://asciinema.org/a/3cqpt9q0c6c1lqatqwxbceqzp.js"
	id="asciicast-3cqpt9q0c6c1lqatqwxbceqzp" async data-autoplay="false" data-size="big" data-preload="false"
	data-theme="solarized-light" class="stretch"></script>

</section>
<section data-markdown>
<script type="text/template">
### Voyez-vous ce qui cloche?
![tototo](res/disass-menu.jpg)

</script>
</section>
<section data-markdown>
<script type="text/template">
### Voyez-vous mieux ce qui cloche?
![tototo](res/disass-menu-2.jpg)

</script>
</section>
<section data-markdown>
<script type="text/template">
### HEIN?!
![tototo](res/disass-menu-3.jpg)

</script>
</section>
<section>
<script type="text/javascript" src="https://asciinema.org/a/386o6vxucae3i8lwhdtehvva5.js"
	id="asciicast-386o6vxucae3i8lwhdtehvva5" async data-autoplay="false" data-size="big" data-preload="false"
	data-theme="solarized-light" class="stretch"></script>

</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
## Segfault

![crash.jpg](res/core.jpg)

Pointeur d'instruction sur 0x41414141

</script>
</section>
<section data-markdown>
<script type="text/template">
## Convention d'appel GNU/Linux x86

* Paramètres sont passés sur la pile
* Sauvegarde du cadre d'activation (*Stack Frame*) sur la pile. (*saved BP*)
* Adresse de retour des fonctions sur la pile (*saved IP*)

</script>
</section>
<section data-markdown>
<script type="text/template">
### En détail

1.  `push` les arguments sur la pile (dans l'ordre inverse)
2. `call`
  1.  `push` l'adresse de la prochaine instruction (adresse de retour)
  2.  change le pointeur d'instruction pour l'adresse spécifiée
  3.  exécute le sous-programme
  4.  `pop` l'adresse de la prochaine instruction dans `eip`
3.  continue l'exécution normalement


</script>
</section>
<section data-markdown>
<script type="text/template">
## Dessin stack avant call et dans sous-programme

</script>
</section>
<section data-markdown>
<script type="text/template">
## Dessins stack avant return, après return

</script>
</section>
<section data-markdown>
<script type="text/template">
### Contenu de la pile dans debug_func
![Stack elements](res/stack-debug-annot.jpg)
![Stack elements](res/stack-debug-overflow-annot.jpg) <!-- .element: class="fragment" data-fragment-index="1" -->

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
### Controler l'exécution

* Nous contrôlons la restoration du pointeur d'instruction
* Nous ne contrôlons que notre input
* Notre input est la seule place par lequel on peut injecter du code

</script>
</section>
<section data-markdown>
<script type="text/template">
## Asciinema exploit

</script>
</section>
<section data-markdown>
<script type="text/template">
## Ce qui s'est passé
Dessin de stack avec retour dans notre buffer.

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
## Protection des zones mémoires

Depuis l'introduction des MMU, les systèmes d'exploitation peuvent marquer certaines pages mémoires pour contrôler les
accès en lecture ou en écriture à ces pages. Le processeur lève un signal lors d'un accès non-authorisé.

En 2004, les premières version de systèmes d'exploitation qui contrôlaient les droit d'accès en exécution à des zones
mémoires. (PaX et ExecShield sous Linux et DEP sous Windows)

De cette façon, il est impossible d'injecter du nouveau code à exécuter dans les variables
locales.

</script>
</section>
<section data-markdown>
<script type="text/template">
## Conséquences sur notre exploit

Demo avec NX (segfault)

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
### Controler l'exécution

* Contrôle sur le pointeur d'instruction via l'adresse de retour <!-- .element: class="fragment highlight-green" data-fragment-index="1" -->
* Injection de code par notre input <!-- .element: class="fragment highlight-red" data-fragment-index="2" -->
* Paramètres sont passés par la pile <!-- .element: class="fragment" data-fragment-index="3" -->

</script>
</section>
<section data-markdown>
<script type="text/template">
## Ret2libc

* Trouver du code pour faire ce que l'on veut dans le code exécutable existant.
* On a accès à n'importe quel segment de code exécutable.
* libc!

Objectif:

Retourner dans `__libc_system` avec les bons arguments (`"/bin/sh"`, clairement!)

</script>
</section>
<section data-markdown>
<script type="text/template">
## Ret2libc - Exploit

On veut faire:

``` C
int system(const char *command);
```

Il nous faut:

 * L'adresse de `__libc_system`
 * Un pointeur vers `"/bin/sh"`

``` bash
$ nm -D libc6.so | grep __libc_system
0003e3e0 T __libc_system
```

``` bash
$ strings --radix=x libc.so | grep "/bin/sh"
15f771 /bin/sh
```

</script>
</section>
<section data-markdown>
<script type="text/template">
## Ret2libc - Exploit - suite

Dessin de stack de ce qu'on veut comme setup

| Details           | Pile              |
|-------------------|-------------------|
| input             | `AAAA` |
| variable locale3  | `AAAA` |
| variable locale2  | `AAAA` |
| variable locale1  | `AAAA` |
| adresse de retour | adresse de `__libc_system` |
|                   | `char * ("/bin/sh")`|

</script>
</section>
<section data-markdown>
<script type="text/template">
## Ret2libc - Exploit - payload

``` python
# Code de l'exploit
``` 

</script>
</section>
</section>

<section>
<section data-markdown>
<script type="text/template">
## x86_64

Changements à la convention d'appel:

Les 6 premiers arguments sont passés via les registres `%rdi, %rsi, %rdx, %rcx, %r8 and %r9`.

Gain de performance considérable par rapport à pousser les paramètres sur la pile.

<!-- Il ne suffit plus de mettre notre pointeur vers `"/bin/sh"`.-->

</script>
</section>
<section data-markdown>
<script type="text/template">
### Controler l'exécution

* Contrôle sur le pointeur d'instruction via l'adresse de retour <!-- .element: class="fragment highlight-green" data-fragment-index="1" -->
* Injection de code par notre input <!-- .element: class="fragment highlight-red" data-fragment-index="2" -->
* Paramètres sont passés par la pile <!-- .element: class="fragment highlight-red" data-fragment-index="3" -->

</script>
</section>
<section data-markdown>
<script type="text/template">
## Contournement

* Il faut passer notre paramètre par `%rdi`.
* Il faut trouver comment changer la valeur de `%rdi`.
* Avec de la chance sans effet de bord.


</script>
</section>
<section data-markdown>
<script type="text/template">
## Return-Oriented Programming

"Utilisation de séquences d'instructions machine appellés *gadgets*.
Chaque *gadget* se termine par un `return` et existe déjà dans les segments exécutables du code binaire de l'application.
En chaînant ces gadgets, l'attaquant peut exécuter des opérations arbitraires sans injecter de code additionnel."

</script>
</section>
<section data-markdown>
<script type="text/template">
## ROP - Exploit

Nous devons donc placer notre pointeur dans `rdi` en ayant contrôle que du contenu de la pile.

L'instruction `pop` fait *exactement* ça.

Gadget cible:
```
pop rdi
ret
```

Plus qu'à avoir le pointeur de pile qui pointe sur notre pointeur vers `"/bin/sh"`.

</script>
</section>
<section data-markdown>
<script type="text/template">
## En détails

1. Retourner sur `pop rdi ; ret` avec l'adresse de `"/bin/sh"` comme prochaine valeur sur la pile.
2. Retourner sur `__libc_system`.

</script>
</section>
<section data-markdown>
<script type="text/template">
## Résultat

``` python
copy pasta du code
```

</script>
</section>
<section data-markdown>
<script type="text/template">
## Trace de l'exploit

GDB script pour voir les returns successifs

</script>
</section>
<section data-markdown>
<script type="text/template">
## Une ROP-chain plus réaliste

Exemple d'une ROP-chain de execve ou read/write/reboot.

</script>
</section>
</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
